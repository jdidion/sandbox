package net.didion.pml;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import javax.xml.bind.JAXBException;

import net.didion.pml.condition.ParentValueCondition;
import net.didion.pml.model.AllowedValues;
import net.didion.pml.model.Property;
import net.didion.pml.model.PropertyDescriptor;
import net.didion.pml.model.PropertyGroup;
import net.didion.pml.util.StringUtils;
import net.didion.pml.util.properties.Properties;
import net.didion.pml.values.Multivalue;
import net.didion.pml.values.ObjectFactory;
import net.didion.pml.values.PmlValuesUtils;
import net.didion.pml.values.PropertyValueDescriptor;

public class PropertyModel {
    private static final String COMMENT = "This file was generated by PML Editor";
    
	private final PropertyDescriptor propertyDescriptor;
	private final Map<Property, PropertyValues> properties;
	private final List<PropertyModelListener> listeners;
	private transient List<Property> variablePropertiesCache;
	
	public PropertyModel(PropertyDescriptor pd) {
	    this.propertyDescriptor = pd;
        this.properties = new LinkedHashMap<Property, PropertyValues>();
        this.listeners = new ArrayList<PropertyModelListener>();
	}
	
	public PropertyModel(PropertyDescriptor pd, Properties<String> baseProperties) {
		this(pd);
		initializeProperties(pd.getProperty(), baseProperties);
		if (pd.getGroup() != null && !pd.getGroup().isEmpty()) {
            for (PropertyGroup group : pd.getGroup()) {
                initializeProperties(group.getProperty(), baseProperties);
            }
        }
	}
	
	private void initializeProperties(List<Property> properties, Properties<String> currentValues) {
	    initializeProperties(properties, currentValues, null, null);
	}
	
	private void initializeProperties(List<Property> properties, Properties<String> currentValues, Property parent, 
	                                  String parentValue) {
		for (Property property : properties) {
		    String currentValue = null;
			if (null != currentValues && currentValues.hasProperty(property.getName())) {
				currentValue = currentValues.getProperty(property.getName());
			}
			
			final PropertyValues values = new PropertyValues(property.getDefaultValues(), currentValue);
			this.properties.put(property, values);
			
			if (null != parent) {
			    values.addCondition(new ParentValueCondition(parent, parentValue));
			}
			
			if (property.getAllowedValues() != null) {
			    final List<Property> children = new ArrayList<Property>();
			    
			    for (AllowedValues av : property.getAllowedValues()) {
			        if (null != av.getProperty() && !av.getProperty().isEmpty()) {
			            // TODO: fix this limitation
			            if (null != parent) {
			                throw new RuntimeException("Multiple levels of nesting not allowed in this version");
			            }
			            initializeProperties(av.getProperty(), currentValues, property, av.getValues());
			            children.addAll(av.getProperty());
			        }
			    }
			    
			    if (!children.isEmpty()) {
			        values.setChildren(children);
			    }
			}
		}
	}


    public PropertyModel(PropertyDescriptor pd, PropertyValueDescriptor pvd) {
        this(pd);
        final Map<String, Object> properties = PmlValuesUtils.descriptorToMap(pvd);
        initializeProperties(pd.getProperty(), properties);
        if (pd.getGroup() != null && !pd.getGroup().isEmpty()) {
            for (PropertyGroup group : pd.getGroup()) {
                initializeProperties(group.getProperty(), properties);
            }
        }
    }
    
    private void initializeProperties(List<Property> properties, Map<String, Object> currentValues) {
        initializeProperties(properties, currentValues, null, null);
    }
    
    private void initializeProperties(List<Property> properties, Map<String, Object> currentValues, Property parent, 
                                      String parentValue) {
        for (Property property : properties) {
            Object currentValue = null;
            if (null != currentValues && currentValues.containsKey(property.getName())) {
                currentValue = currentValues.get(property.getName());
            }
            
            final PropertyValues values = new PropertyValues(property.getDefaultValues());
            if (null == currentValue) {
                values.setValue(property.getDefaultValues());
            }
            else if (currentValue instanceof String) {
                values.setValue((String) currentValue);
            }
            else {
                final Multivalue mv = (Multivalue) currentValue;
                values.setVariableValues(mv.getValue());
            }
            this.properties.put(property, values);
            
            if (null != parent) {
                values.addCondition(new ParentValueCondition(parent, parentValue));
            }
            
            if (property.getAllowedValues() != null) {
                final List<Property> children = new ArrayList<Property>();
                
                for (AllowedValues av : property.getAllowedValues()) {
                    if (null != av.getProperty() && !av.getProperty().isEmpty()) {
                        // TODO: fix this limitation
                        if (null != parent) {
                            throw new RuntimeException("Multiple levels of nesting not allowed in this version");
                        }
                        initializeProperties(av.getProperty(), currentValues, property, av.getValues());
                        children.addAll(av.getProperty());
                    }
                }
                
                if (!children.isEmpty()) {
                    values.setChildren(children);
                }
            }
        }
    }
    
	public void addListener(PropertyModelListener listener) {
	    this.listeners.add(listener);
	}
	
	public void removeListener(PropertyModelListener listener) {
	    this.listeners.remove(listener);
	}
	
	private boolean hasListeners() {
	    return null != this.listeners && !this.listeners.isEmpty();
	}
	
	public PropertyDescriptor getPropertyDescriptor() {
		return this.propertyDescriptor;
	}
	
	public boolean isEnabled(Property property) {
	    return this.properties.get(property).isEnabled();
	}
	
	public boolean isEditable(Property property) {
	    return isEnabled(property) && property.isEditable();
	}
	
	public String getValue(Property property) {
        return this.properties.get(property).getValue();
    }
    
    public void setValue(Property property, String value) {
        if (!isEditable(property)) {
            throw new IllegalArgumentException("Property " + property.getName() + " is not editable.");
        }
        final PropertyValues values = this.properties.get(property);
        final String oldValue = values.getValue();
        if (!equal(value, oldValue)) {
            // TODO: this is a really clunky way to do this
            Map<Property,Boolean> enabled = null;
            if (values.isParent()) {
                enabled = new HashMap<Property, Boolean>();
                for (Property child : values.getChildren()) {
                    enabled.put(child, isEnabled(child));
                }
            }
            
            values.setValue(value);
            
            if (null != enabled) {
                for (Property child : enabled.keySet()) {
                    boolean newValue = isEnabled(child);
                    if (enabled.get(child) == newValue) {
                        enabled.remove(child);
                    }
                }
            }
            
            if (hasListeners()) {
                for (PropertyModelListener listener : this.listeners) {
                    listener.propertyValueChanged(property, oldValue, value);
                    if (null != enabled) {
                        for (Property child : enabled.keySet()) {
                            if (enabled.get(child)) {
                                listener.propertyDisabled(property);
                            }
                            else {
                                listener.propertyEnabled(property);
                            }
                        }
                    }
                }
            }
        }
    }
	
    public boolean hasVariables() {
        return !getVariableProperties().isEmpty();
    }
    
	public boolean isVariable(Property property) {
		final PropertyValues values = this.properties.get(property);
		return values.isEnabled() && values.isVariable();
	}
	
	public boolean isParent(Property property) {
	    return this.properties.get(property).isParent();
	}
	
	public List<Property> getVariableProperties() {
	    if (null == this.variablePropertiesCache) {
    	    final List<Property> variableProperties = new ArrayList<Property>();
    	    for (Property property : this.properties.keySet()) {
    	        if (isVariable(property)) {
    	            variableProperties.add(property);
    	        }
    	    }
    	    this.variablePropertiesCache = Collections.unmodifiableList(variableProperties);
        }
    	return Collections.unmodifiableList(this.variablePropertiesCache);    
	}
	
	public Property getVariableProperty(int index) {
	    if (index >= getVariableProperties().size()) {
	        throw new IllegalArgumentException("Invalid index:  + index");
	    }
	    return getVariableProperties().get(index);
	}
	
	public List<String> getVariableValues(int index) {
	    return getVariableValues(getVariableProperty(index));
	}
	
	public List<String> getVariableValues(Property property) {
        if (!isVariable(property)) {
            throw new IllegalArgumentException("Not a variable property");
        }
        return this.properties.get(property).getVariableValues();
    }
    
	public List<String> getVariableRow(int rowIndex) {
	    if (rowIndex >= getNumVariableCombinations()) {
	        throw new IllegalArgumentException("Invalid variable row index: " + rowIndex);
	    }
	    
	    final int numVars = getNumVariables();
	    final int[] divisors = new int[numVars-1];
        
        for (int i = numVars-1; i > 0; i--) {
            final int numValues = getVariableValues(i).size();
            divisors[i-1] = numValues;
        }
        
        final String[] row = new String[numVars];
        int i = rowIndex;
        for (int x = divisors.length-1; x >= 0; x--) {
            final String value;
            final int divisor = divisors[x];
            
            if (divisor == 1) {
                value = getVariableValues(x+1).get(0);
            }
            else {
                value = getVariableValues(x+1).get(i % divisor);
                i = i / divisor;
            }
            
            row[x+1] = value;
        }
        row[0] = getVariableValues(0).get(i);
        
        return Arrays.asList(row);
    }
	
	public void setVariableValues(Property property, List<String> values) {
	    if (!isEditable(property)) {
            throw new IllegalArgumentException("Property " + property.getName() + " is not editable.");
        }
	    final PropertyValues propertyValues = this.properties.get(property);
	    final boolean isVariable = propertyValues.isVariable();
	    
	    if (null != values && !values.isEmpty()) {
	        final List<String> newValues = new ArrayList<String>(values);
	        
	        if (isVariable) {
	            final List<String> oldValues = propertyValues.getVariableValues();
	            propertyValues.setVariableValues(newValues);
	        
    	        if (hasListeners()) {
    	            for (PropertyModelListener listener : this.listeners) {
    	                listener.variablePropertyValueChanged(property, oldValues, newValues);
    	            }
    	        }
	        }
	        else {
	            propertyValues.setVariableValues(newValues);
	            this.variablePropertiesCache = null;
	            
	            if (hasListeners()) {
                    for (PropertyModelListener listener : this.listeners) {
                        listener.variablePropertyAdded(property, propertyValues.getValue(), newValues);
                    }
	            }
	        }
	    }
	    else if (isVariable) {
            removeVariable(property);
        }
    }
	
    public void removeVariable(Property property) {
        if (!isVariable(property)) {
            return;
        }
        
	    final PropertyValues values = this.properties.get(property);
	    final List<String> oldValue = values.getVariableValues();
    	values.clearVariableValues();
	    
    	this.variablePropertiesCache = null;
    	
	    if (hasListeners()) {
            for (PropertyModelListener listener : this.listeners) {
                listener.variablePropertyRemoved(property, oldValue, values.getValue());
            }
	    }   
	}
	
	public int getNumVariables() {
	    return getVariableProperties().size();
	}
	
	public int getNumVariableCombinations() {
	    final List<Property> vars = getVariableProperties();
	    int count = 1;
	    for (Property p : vars) {
	        count *= this.properties.get(p).getVariableValues().size();
	    }
	    return count;
	}
	
    public void save(File file) throws JAXBException {
        final ObjectFactory factory = new ObjectFactory();
        final PropertyValueDescriptor desc = factory.createPropertyValueDescriptor();
        
        for (Property property : this.properties.keySet()) {
            final PropertyValues values = this.properties.get(property);
            if (values.isEnabled()) {
                final net.didion.pml.values.Property p = factory.createProperty();
                p.setName(property.getName());
                
                if (values.isVariable()) {
                    final Multivalue mv = factory.createMultivalue();
                    mv.getValue().addAll(values.getVariableValues());
                    p.setMultivalue(mv);
                }
                else {
                    p.setValue(getValue(property));
                }
                
                desc.getProperty().add(p);
            }
        }
        
        PmlValuesUtils.write(desc, file);
    }
	
    /**
     * Generate property files.
     * 
     * @param dir
     * @param file
     * @param createDirectories
     * @param useXmlFormat
     * @throws IOException
     */
	public void generate(File dir, String file, boolean createDirectories, boolean useXmlFormat) throws IOException {
		final Properties<String> defaultProperties = Properties.getStringInstance();
	    final List<PropertyValues> variables = new ArrayList<PropertyValues>();
	    
	    for (Property property : this.properties.keySet()) {
	        final PropertyValues values = this.properties.get(property);
	        if (values.isEnabled()) {
    	        if (values.isVariable()) {
    	            variables.add(values);
    	        }
    	        else if (values.hasValue()) {
    	            defaultProperties.setProperty(property.getName(), values.getValue());
    	        }
	        }
	    }
	    
	    // if there are no variable properties, just write a single property file
	    if (variables.isEmpty()) {
	        defaultProperties.setComment(COMMENT);
	        store(defaultProperties, new File(dir, file), useXmlFormat);
	    }
	    // else, write a separate property file for each variable combination
	    else {
	        final Properties<String> properties = Properties.getStringInstance(defaultProperties);
	        properties.setComment(COMMENT);
	        final int numVars = variables.size();
	        final int[] divisors = new int[numVars-1];
	        
	        int size = getVariableValues(0).size();
	        for (int i = numVars-1; i > 0; i--) {
	            final int numValues = getVariableValues(i).size();
	            size *= numValues;
	            divisors[i-1] = numValues;
	        }
	        
	        final int padDigits = (int) Math.ceil(Math.log(size));
	        
	        for (int i = 0; i < size; i++) {
	            properties.clear();
	            
	            int n = i;
	            for (int j = divisors.length-1; j >= 0; j--) {
	                final String value;
	                final int divisor = divisors[j];
                    
	                if (divisor == 1) {
	                    value = getVariableValues(j+1).get(0);
	                }
	                else {
	                    value = getVariableValues(j+1).get(n % divisor);
	                    n = n / divisor;
	                }
	                
	                properties.setProperty(getVariableProperty(j+1).getName(), value);
	            }
	            
	            properties.setProperty(getVariableProperty(0).getName(), getVariableValues(0).get(i));
	            
	            store(properties, createFile(dir, file, i, padDigits, createDirectories, useXmlFormat), useXmlFormat);
	        }
	    }
	}
	
	private File createFile(File dir, String baseName, int i, int padDigits, boolean createDirectory, boolean xml) {
	    final StringBuilder sb = new StringBuilder(baseName).append(StringUtils.prepadInt(i, padDigits));
	    if (createDirectory) {
	        dir = new File(dir, sb.toString());
	        dir.mkdirs();
	    }
	    sb.append(".properties");
	    if (xml) {
	        sb.append(".xml");
	    }
	    return new File(dir, sb.toString());
    }

    private void store(Properties<String> properties, File file, boolean useXmlFormat) throws IOException {
	    OutputStream os = null;
	    try {
	        os = new FileOutputStream(file);
    	    if (useXmlFormat) {
                properties.storeToXml(os);
            }
            else {
                properties.store(os);
            }
	    }
	    finally {
	        if (null != os) {
	            try {
	                os.close();
	            }
	            catch (IOException ex) {
	                // ignore
	            }
	        }
	    }
	}    
    
    private boolean equal(String s1, String s2) {
        return (null == s1) ? (null == s2) : s1.equals(s2);
    }
    
    private class PropertyValues {
        private String defaultValue;
        private String value;
        private List<String> variableValues;
        private List<PropertyCondition> conditions;
        private List<Property> children;
        
        PropertyValues() {
        }
        
        PropertyValues(String defaultValue) {
            this(defaultValue, defaultValue);
        }
        
        PropertyValues(String defaultValue, String currentValue) {
            this.defaultValue = defaultValue;
            setValue((null == currentValue) ? defaultValue : currentValue);
        }
        
        PropertyValues(String defaultValue, List<String> variableValues) {
            this(defaultValue);
            setVariableValues(variableValues);
        }
        
        String getDefaultValue() {
            return this.defaultValue;
        }
        
        boolean hasValue() {
            return null != this.value;
        }
        
        String getValue() {
            return this.value;
        }
        
        void setValue(String value) {
            this.value = value;
        }
        
        void resetValue() {
            setValue(this.defaultValue);
        }
        
        boolean isVariable() {
            return (null != this.variableValues);
        }
        
        List<String> getVariableValues() {
            return Collections.unmodifiableList(this.variableValues);
        }
        
        void setVariableValues(List<String> values) {
            this.variableValues =  (null == values || values.isEmpty()) ? null : new ArrayList<String>(values);
        }
        
        public void clearVariableValues() {
            this.variableValues = null;
        }
        
        boolean isConditional() {
            return (null != this.conditions);
        }
        
        void addCondition(PropertyCondition condition) {
            if (null == this.conditions) {
                this.conditions = new ArrayList<PropertyCondition>();
            }
            this.conditions.add(condition);
        }
        
        boolean isEnabled() {
            if (null != this.conditions) {
                for (PropertyCondition c : this.conditions) {
                    if (!c.isSatisfied(PropertyModel.this)) {
                        return false;
                    }
                }
            }
            return true;
        }
        
        boolean isParent() {
            return (null != this.children);
        }
        
        List<Property> getChildren() {
            return this.children;
        }
        
        void setChildren(List<Property> children) {
            this.children = children;
        }
    }
}
